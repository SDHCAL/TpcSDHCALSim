  /// \file SteppingAction.cc
/*
 *
 * SteppingAction.cc source template automatically generated by a class generator
 * Creation date : mer. juil. 9 2014
 *
 * This file is part of TpcSDHCALSim libraries.
 * 
 * TpcSDHCALSim is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * TpcSDHCALSim is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with TpcSDHCALSim.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "SteppingAction.h"

// geant4
#include "G4Step.hh"

// tpc sdhcal
#include "RootFileManager.h"


namespace tpc_sdhcal
{

SteppingAction::SteppingAction() :
 	 m_muMomentumCut(0.5),  // in GeV
 	 m_emMomentumCut(1),  // in GeV
 	 m_hadronsAndNucleusMomentumCut(0.2),  // in GeV
 	 m_calorimeterFrontBorderLimit(900*mm),
 	 m_tpcEnteringMomentumCut(1),  // in GeV
 	 m_neutronMomentumCut(2),
 	 m_calorimeterFrontFaceVolumeName("CalorimeterFrontFaceVolume"),
 	 m_targetVolumeName("TargetVolume"),
 	 m_magneticFieldVolumeName("MagneticFieldVolume"),
 	 m_rootTreeName("AnalysisTree")
{

}

//------------------------------------------------------------------------------------------------------------------------------------------

SteppingAction::~SteppingAction() 
{

}

//------------------------------------------------------------------------------------------------------------------------------------------

void SteppingAction::UserSteppingAction(const G4Step *pStep)
{
	G4StepPoint *pPreStepPoint = pStep->GetPreStepPoint();
	G4StepPoint *pPostStepPoint = pStep->GetPostStepPoint();
	G4String preVolumeName = pPreStepPoint->GetPhysicalVolume()->GetLogicalVolume()->GetName();
	G4VPhysicalVolume *pPostPhysicalVolume = pPostStepPoint->GetPhysicalVolume();
	G4String postVolumeName = "";

	if(NULL != pPostPhysicalVolume)
		postVolumeName = pPostPhysicalVolume->GetLogicalVolume()->GetName();

	// extract info on particle that enter the calorimeter front face
	if(fGeomBoundary == pPostStepPoint->GetStepStatus()
	&& m_magneticFieldVolumeName == preVolumeName
	&& m_calorimeterFrontFaceVolumeName == postVolumeName)
	{
		if(DoesStepPassesCuts(pStep, false))
		{
//			std::cout << "Entering particle : " << pStep->GetTrack()->GetDefinition()->GetParticleName();
//			std::cout << " of momentum : " << pPostStepPoint->GetMomentum().mag()/GeV << " GeV. "
//					"Momentum direction : " << pPostStepPoint->GetMomentum().unit() << std::endl;

			this->ExtractCalorimeterFrontFaceInfo(pStep);
		}
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------

void SteppingAction::BeginOfEvent()
{
	m_calorimeterFrontFaceTrackList.clear();
	m_tpcTrackList.clear();
 m_nConsideredParticles = 0;
 m_enteringPointAtCaloX.clear();
 m_enteringPointAtCaloY.clear();
 m_particleChargeAtCalo.clear();
 m_particleMomentumAtCaloX.clear();
 m_particleMomentumAtCaloY.clear();
 m_particleMomentumAtCaloZ.clear();
 m_particleMomentumAtCalo.clear();
 m_particleTrackIDAtCalo.clear();
 m_totalEventMomentumAtCalo = 0;
 m_meanDistanceBetweenParticlesAtCalo = 0;
 m_highestMomentumAtCalo = 0;
 m_nParticlesAtCalo = 0;
 m_nChargedParticleInTpc = 0;
 m_nNonEntringChargedParticleInTpc = 0;
 m_nParticlesAtCaloInEdges = 0;
 m_minimumDistanceBetweenParticlesAtCalo = 0;
 m_nNeutralParticlesAtCalo = 0;
 m_nChargedParticlesAtCalo = 0;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void SteppingAction::EndOfEvent()
{
	m_minimumDistanceBetweenParticlesAtCalo = std::numeric_limits<double>::max();
	unsigned int normalization = 0;

	for(unsigned int i=0 ; i<m_enteringPointAtCaloX.size() ; i++)
	{
		G4double meanDistance = 0.f;

		for(unsigned int j=i+1 ; j<m_enteringPointAtCaloX.size() ; j++)
		{
			if(i == j)
				continue;

			G4double distance = std::sqrt(std::pow(m_enteringPointAtCaloX.at(i)-m_enteringPointAtCaloX.at(j), 2)
				                 + std::pow(m_enteringPointAtCaloY.at(i)-m_enteringPointAtCaloY.at(j), 2) );

			if(distance < m_minimumDistanceBetweenParticlesAtCalo)
				m_minimumDistanceBetweenParticlesAtCalo = distance;

			meanDistance += distance;

			normalization++;
		}

		m_meanDistanceBetweenParticlesAtCalo += meanDistance;
	}

	if(m_enteringPointAtCaloX.size() <= 1)
		m_minimumDistanceBetweenParticlesAtCalo = 0;

	if(m_enteringPointAtCaloX.size() != 1)
	 m_meanDistanceBetweenParticlesAtCalo /= normalization;

	std::cout << "m_meanDistanceBetweenParticlesAtCalo : " << m_meanDistanceBetweenParticlesAtCalo << " mm" << std::endl;
	std::cout << "m_totalEventMomentumAtCalo : " << m_totalEventMomentumAtCalo/GeV << " GeV" << std::endl;
	std::cout << "m_nParticlesAtCalo : " << m_nParticlesAtCalo << std::endl;
	std::cout << "m_highestMomentumAtCalo : " << m_highestMomentumAtCalo/GeV << " GeV" << std::endl;
	std::cout << "m_minimumDistanceBetweenParticlesAtCalo : " << m_minimumDistanceBetweenParticlesAtCalo << " mm" << std::endl;

	RootFileManager *pRootFileManager = RootFileManager::GetInstance();

	if(!pRootFileManager->IsFileOpened())
		return;

	pRootFileManager->Set(m_rootTreeName, "nParticlesAtCalo", m_nParticlesAtCalo);
	pRootFileManager->Set(m_rootTreeName, "nNeutralParticlesAtCalo", m_nNeutralParticlesAtCalo);
	pRootFileManager->Set(m_rootTreeName, "nChargedParticlesAtCalo", m_nChargedParticlesAtCalo);
	pRootFileManager->Set(m_rootTreeName, "meanDistanceBetweenParticlesAtCalo", m_meanDistanceBetweenParticlesAtCalo);
	pRootFileManager->Set(m_rootTreeName, "totalEventMomentumAtCalo", m_totalEventMomentumAtCalo);
	pRootFileManager->Set(m_rootTreeName, "minimumDistanceBetweenParticlesAtCalo", m_minimumDistanceBetweenParticlesAtCalo);
	pRootFileManager->Set(m_rootTreeName, "highestMomentumAtCalo", m_highestMomentumAtCalo);
	pRootFileManager->Set(m_rootTreeName, "enteringPointAtCaloX", &m_enteringPointAtCaloX);
	pRootFileManager->Set(m_rootTreeName, "enteringPointAtCaloY", &m_enteringPointAtCaloY);
	pRootFileManager->Set(m_rootTreeName, "particleChargeAtCalo", &m_particleChargeAtCalo);
	pRootFileManager->Set(m_rootTreeName, "particleMomentumAtCaloX", &m_particleMomentumAtCaloX);
	pRootFileManager->Set(m_rootTreeName, "particleMomentumAtCaloY", &m_particleMomentumAtCaloY);
	pRootFileManager->Set(m_rootTreeName, "particleMomentumAtCaloZ", &m_particleMomentumAtCaloZ);
	pRootFileManager->Set(m_rootTreeName, "particleMomentumAtCalo", &m_particleMomentumAtCalo);
	pRootFileManager->Set(m_rootTreeName, "particleTrackIDAtCalo", &m_particleTrackIDAtCalo);

	pRootFileManager->Fill(m_rootTreeName);
}

//------------------------------------------------------------------------------------------------------------------------------------------

void SteppingAction::ExtractCalorimeterFrontFaceInfo(const G4Step *pStep)
{
	G4StepPoint *pPreStepPoint = pStep->GetPreStepPoint();
	G4StepPoint *pPostStepPoint = pStep->GetPostStepPoint();

	m_enteringPointAtCaloX.push_back(pPostStepPoint->GetPosition().x());
	m_enteringPointAtCaloY.push_back(pPostStepPoint->GetPosition().y());
	m_particleChargeAtCalo.push_back(pStep->GetTrack()->GetDefinition()->GetPDGCharge());

	G4ThreeVector momentumVector = pPostStepPoint->GetMomentum();
	m_particleMomentumAtCaloX.push_back(momentumVector.x());
	m_particleMomentumAtCaloY.push_back(momentumVector.y());
	m_particleMomentumAtCaloZ.push_back(momentumVector.z());
	m_particleMomentumAtCalo.push_back(momentumVector.mag());
	m_particleTrackIDAtCalo.push_back(pStep->GetTrack()->GetTrackID());

	m_totalEventMomentumAtCalo += momentumVector.mag();
	m_nParticlesAtCalo ++;

	if(momentumVector.mag() > m_highestMomentumAtCalo)
		m_highestMomentumAtCalo = momentumVector.mag();

	if(0 == pStep->GetTrack()->GetDefinition()->GetPDGCharge())
		m_nNeutralParticlesAtCalo++;
	else
		m_nChargedParticlesAtCalo++;


}

//------------------------------------------------------------------------------------------------------------------------------------------

void SteppingAction::ExtractTPCInfo(const G4Step *pStep)
{

}

//------------------------------------------------------------------------------------------------------------------------------------------

bool SteppingAction::DoesStepPassesCuts(const G4Step *pStep, bool usePreStep)
{
	G4StepPoint *pStepPoint = NULL;
	if(usePreStep)
		pStepPoint = pStep->GetPreStepPoint();
	else
		pStepPoint = pStep->GetPostStepPoint();

	const G4ThreeVector momentum = pStepPoint->GetMomentum();
	const G4double momentumMag = pStepPoint->GetMomentum().mag()/GeV;
	const G4String particleName = pStep->GetTrack()->GetDefinition()->GetParticleName();

	if(momentum.z() < 0)
		return false;

	// neutrino does not contribute
	if(particleName.find("nu") != G4String::npos)
		return false;

	if(particleName.find("mu") != G4String::npos
	&& m_muMomentumCut > momentumMag)
		return false;

	if( ("e+" == particleName || "e-" == particleName || "gamma" == particleName)
		&& m_emMomentumCut > momentumMag)
		return false;

	if("neutron" == particleName
	&& m_neutronMomentumCut > momentumMag)
		return false;

	if(m_hadronsAndNucleusMomentumCut > momentumMag)
		return false;

	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void SteppingAction::Clear()
{

}



} 

