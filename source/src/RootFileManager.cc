  /// \file RootFileManager.cc
/*
 *
 * RootFileManager.cc source template automatically generated by a class generator
 * Creation date : mer. juil. 9 2014
 *
 * This file is part of TpcSDHCALSim libraries.
 * 
 * TpcSDHCALSim is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * TpcSDHCALSim is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with TpcSDHCALSim.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "RootFileManager.h"

#include "TFile.h"
#include "TTree.h"

namespace tpc_sdhcal
{

RootFileManager *RootFileManager::m_pInstance = NULL;

//------------------------------------------------------------------------------------------------------------------------------------------

RootFileManager::RootFileManager() :
		m_pRootFile(NULL),
		m_pTTreeWrapper(NULL),
		m_rootFileName("")
{

}

//------------------------------------------------------------------------------------------------------------------------------------------

RootFileManager::~RootFileManager() 
{
	Clear();
}

//------------------------------------------------------------------------------------------------------------------------------------------

RootFileManager *RootFileManager::GetInstance()
{
	if(NULL == m_pInstance)
		m_pInstance = new RootFileManager();

	return m_pInstance;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void RootFileManager::Kill()
{
	if(NULL != m_pInstance)
	{
		delete m_pInstance;
		m_pInstance = NULL;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool RootFileManager::OpenFile(const G4String &fileName)
{
	if(NULL != m_pRootFile)
		return false;

	if(fileName.empty())
		return false;

	m_pRootFile = new TFile(fileName.c_str(), "RECREATE");

	if(NULL == m_pRootFile)
		return false;

	m_rootFileName = fileName;

	m_pTTreeWrapper = new TTreeWrapper();

	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool RootFileManager::IsFileOpened() const
{
	return (NULL != m_pRootFile);
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool RootFileManager::Write()
{
	if(NULL == m_pRootFile)
		return false;

	if(m_pTTreeWrapper->m_treeMap.empty())
		return false;

	for(TTreeWrapper::TreeMap::iterator iter = m_pTTreeWrapper->m_treeMap.begin() , endIter = m_pTTreeWrapper->m_treeMap.end() ;
			endIter != iter ; ++iter)
	{
		iter->second.first->SetDirectory(m_pRootFile);
		iter->second.first->Print();
		std::cout << std::endl;
	}

	m_pRootFile->Write();
	m_pRootFile->Close();

	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool RootFileManager::Fill(const G4String &treeName)
{
	if(NULL == m_pRootFile)
		return false;

	try
	{
		m_pTTreeWrapper->Fill(treeName);
	}
	catch(TTreeWrapper::TreeNotFoundError &error)
	{
		std::cout << "RootFileManager::Fill() : Tree '" << treeName << "' not found !!" << std::endl;
		return false;
	}

	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool RootFileManager::Print(const G4String &treeName)
{
	if(NULL == m_pRootFile)
		return false;

	try
	{
		m_pTTreeWrapper->Print(treeName);
	}
	catch(TTreeWrapper::TreeNotFoundError &error)
	{
		std::cout << "RootFileManager::Print() : Tree '" << treeName << "' not found !!" << std::endl;
		return false;
	}

	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool RootFileManager::Scan(const G4String &treeName)
{
	if(NULL == m_pRootFile)
		return false;

	try
	{
		m_pTTreeWrapper->Scan(treeName);
	}
	catch(TTreeWrapper::TreeNotFoundError &error)
	{
		std::cout << "RootFileManager::Scan() : Tree '" << treeName << "' not found !!" << std::endl;
		return false;
	}

	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------

TTree *RootFileManager::GetTree(const G4String &treeName)
{
	return m_pTTreeWrapper->GetTree(treeName);
}

//------------------------------------------------------------------------------------------------------------------------------------------

void RootFileManager::Clear()
{
	if(NULL != m_pRootFile)
	{
		delete m_pRootFile;
		m_pRootFile = NULL;
	}

	if(NULL != m_pTTreeWrapper)
	{
		m_pTTreeWrapper->Clear();
		delete m_pTTreeWrapper;
	}
}

} 

